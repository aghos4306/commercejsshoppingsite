## Install dependencies @material-ui/core @material-ui/icons @chec/commerce.js @stripe/react-stripe-js @stripe/stripe-js react-router-dom react-hook-form

## Delete src folder and re-create it from scratch starting with index.js and App.css...

## Products Component: creata a funtion based component for products, create arbitratry products as an array of object. Within the Products function, run map function on the products created. For each product we return properties specific for that product. This Product is the singular product component.

## Single Product component. This component is going to have all specific layout for each product e.g image, description, title etc. import from material ui Card, CardMedia, CardContent, CardAction, Typography, IconBotton. import { AddShoppingCart } from '@material-ui/icons'. The Product is a material ui card component. The title which is product.name comes from Products since Product is a child component to Products. Since Product is rendered in Products, we can pass props into Product component that is rendered in Products.js file. The prop is product, which is the entire product we are looping over. Inside of Product.jsx we have access to product.name, product.id, product.description, product.price once they are destructure in Product.jsx component. An alternative to pass them as props, props, then inside Typography we will instead have props.product.price, props.product.name etc.

# Create styles.js file inside Product folder. This style is used have all the classes used to style single Product. Create the style, and apply them in Product.jsx component. Now go to App.js component and import Products component here, and render Products within the div.

## Navigation bar.Create a Navbar component. Import AppBar, Toolbar, IconButton, Badge, MenuItem, Menu, Typography from material-ui/core. Create Navbar layout.

## Navbar image. create assets folder inside src. paste image inside assets folder. import this image as logo into Navbar.jsx and just use the logo. Build the navbar, import it into App.js file and render it.

# Create styles.js file for Products. Style Products cos navbar overlaps with products.

## Fetch Products from commerce js store. Create in components lib -> commerce.js. import Commerce from @chec/commerce.js. Create a new instance of Commerce. Create an account on commercejs.com to get public and private key. create .env file on the root where you will store public key from commerce. Pass this public key into Commerce by using process.env.NAME, pass in a second argument of true. We just created a commerce store. This commerce object can be used all over the application. Usually creating a full fledge ecommerce store, you need a backend api for creating products, fetching products, deleting, updating, authentication and a lot more. All of these is stored in this commerce instance we just created.

## Import commerce into App.js. Still in App.js use the useState hook to fetch products, by default the products is an empty array. use the useEffect hook to populate the products immediately the application loads. The function we create now fetchProducts will asynchronously get all products. Destructure the data from the products. The data is going to be the products. Once the products is set into setProducts, we now call the created fetchProducts function inside the useEffect hook. The empty array means that the fetchProducts function is only going to run at the start of the render. In class based component, this is called componentDidMount. Recap, the fetchProducts function called inside the useEffect hook will call our commerce products list and set the products to the state. console.log(products) gives first an empty array and then undefined. If you go to commerce.js dashboard and go to Products, you will see that Products array is completely empty. You can add products straight from the dashboard. Lets add couple products. sku field should be left empty for commerce js to automatically generate products id. Specify the products e.g keyboard in commerce dashboard. Upon refreshing, you notice the console now have one product. Add more products through commerce js dashboard. As you can see now on the console, the array is now filled with 8 objects.

## Instead of having mockup products, to display these products from commerce, we have to pass them as props to our Products component rendered inside App.js file. Now go to Products.jsx components, destructure products here also. We can comment out now the test products array. We now have the access to the real products. For each product, we send specific product object inside Product component. Most of the work now is going to be done inside the Product.jsx component.

# Product component. Check what property product object have.To test console.log(product) and return <div>Product Sample</div> just so that we dont return the actual return which might give error at this state of development. We can see each product object on the console. Now which properties do we need from each one of these object? product.image will be product.media.source, product.name stays same, product.price will be product.price.formatted_with_symbol. Products are now fetched from commerce into site. An issue is that the description is displays with html tags. To remove this tag, render the description to remove the html tag using dangerouslySetInnerHTML={{__html: product.description}} within Typography. And make the Typography a self closing tag, also remove rendered {product.description} otherwise you will get this error 'Unhandled Rejection (Error): Can only set one of `children` or `props.dangerouslySetInnerHTML`.'

## Add Products to Cart. Still in App.js. Cart will be managed by commercejs. Our cart is going to be another state in react. The cart is going to initially set to an empty object using the useState hook. Just like we created fetchProducts function to handle products, we also create an async fetchCart function to handle carting. You see the pattern. Console.log(cart), you see at the start cart does not exist, later on cart is populated. Notice the cart object has a property of currency, created, subtotal, discount_code, line_items etc. We are interested in line_items, which is the items we will add to the cart, and subtotal which is the total price of the items that are currently in the cart.

# Create function that actually pushes the product to cart. Still in App.js, The function handleAddToCart performs this task. This function accepts two parameters, productId and quantity.Use these param to pass to commerce api and then add to cart. Now update the cart to this item. Now where do we use this handleAddToCart function. We cannot use it here in App.js cos we dont have the addtocart button here. We will use it in the Product.jsx component. In the rendered Products inside App.js, we pass handleAddtoCart as props as onAddToCart. Go to Products.jsx and also pass in onAddToCart as props. This is the function that will add item to cart. Still in Products.jsx file pass onAddToCart one level deeper into rendered Product component here. Now in Product.jsx pass destructure onAddToCart, and on the IconButton,dont call like this onClick={onAddToCart}, cos it will call itself immediately. Instead call like this onClick={() => onAddToCart(product.id, 1)}> The product.id is identifies each individual product, and the 1 is the quantity as we add items one by one. Now we should be able to update the cart depending on what is clicked. Even though the cart icon count is still static, Upon clicking an item, on the console, we get a new cart that has line_items which was initially an empty array, but now it has one item in it. Click another item, you get that also added to the cart in console. It calculates the subtotal progressively. Now we have to use the data from the cart to display a dynamic icon on the cart in the UI.

# Display Data from cart console on UI. We now go to Navbar.jsx because the cart icon is in the navbar. We have to get the information about the cart and use it here. Firstly pass totalItems as props to the rendered Navbar in App.js file. totalItems is the total number of items in the cart. Now go to Navbar and destructure totalItems, and pass totalItems as props to Badge i.e badgeContent={totalItems}. Items are now dynamically displayed in the cart. As you notice, commerce api stores the item, the cart item persist upon refresh.

## Create cart layout. Once cart is clicked, we want to display all the items we have in the cart. Add more items, remove items, head to checkout. In components -> Cart-> cart.jsx. Create a function component and import required material-ui core comp. Create layout of Cart. Recall the className toobar pushes the container a little more down so it does not overlap with in the navbar. We define a variable isEmpty, we dynamically render the cart depending if its empty or not. If isEmpty display the component EmptyCart. EmptyCart is a sub component. else display FilledCart which is also a sub component. These components are created inside the Cart components cos they are really simple elements. If there are items, return a grid and loop through cart items. Right now we do not have any cart items, we do not even have the cart destructured yet, pass cart through props from App.js to Cart.jsx. In App.js we have cart in the state, import and render Cart, comment out the rendered Products. Now pass cart as props in the rendered Cart component. We comment out Products component right now but later on we will implement react router so we can navigate between the Product and the Cart. In Cart.jsx component we can now pass destructure cart. How do we know the cart is empty? Answer: cart.line_items.length === 0, this is possible cos line_items is an array. If cart is not empty, loop through line_items using map method. Instantaneously return a Grid which renders CartItem component, this component will be created shortly. For simplicity just return name of item for now. Getting cannot read property line of undefined, meaning line_items wasn't fetched yet. Instead of defining the line_items in isEmpty and passing isEmpty, use line_items straigt forward.

# CartItem Component. Create Cart -> CartItem -> CartItem.jsx component. I created the CartItem inside the Cart cos the CartItem is only going to be used inside the Cart. Create a functional component and import needed material ui core component. Now that we created CartItem component, import and render CartItem in Cart.jsx, pass item as props into the rendered CartItem inside Cart.jsx. We can now go to CartItem.jsx component and destructure item, cos we know that we are receiving now item through props.

## Implement React Routes. In App.js import BrowserRouter, Switch, Route.

## Add Redirect upon clicking cart button. Go to Navbar component cos that is where this button is located. Import Link from react-router-dom

## Remove Cart Icon if we are already on the Cart. Still in Navbar.jsx, import useLocation hook. useLocation hook has the property pathname. If location.pathname is equal to home, show Cart Badge.

## If there are no Item in the Cart, Add Link that directs users to all products. Inside Cart.jsx, import Link and implement.

## Build Logic for Cart Button, decrementing, incrementing, removing product from cart, empty entire cart, heading to checkout.

# Update Quantity of Specific Product. Go to App.js file, we have cart in useState. We call some of the features from commerce js on the cart. handleUpdateCartQty function performs this task. This function takes productId and quantity as parameters. As the response, Call the update method on commerce js. The update takes in productId, and quantity as a object. Create also handleRemoveFromCart and handleEmptyCart function. Now we have these three functions which is updating our state. We now need to decide where to pass these functions into to call them. Still in App.js file pass these three functions as props to the Rendered Cart component. Now go to Cart.jsx component and destructure these three functions there. Notice in the Cart.jsx component, some of those functions can be called in or passed here, some will not be passed here. The empty button will be called in from here. Use onClick listener to handle emptying the cart. handleUpdateCartQty and handleRemoveFromCart will be passed to CartItem component rendered here as props. Then destructured in CartItems.jsx component, then passed down to remove from cart button and update quantity button respectively. The props is passed in like this onUpdateCartQty={handleUpdateCartQty} and onRemoveFromCart={handleRemoveFromCart}. Pass in as onClick listener, onUpdateCartQty to both + and - button. This onUpdateCartQty takes two parameters, item.id, and item.quantity. On the decrement it should be item.quantity - 1, on increment it should be item.id +1, This sends the new updated quantity for this specific item. With these done, all the buttons should be functioning now. Even the price is increased, the power of commerce.

## Payment Functionality, Stripe, Layout for form. In Cart.jsx import Link, init component as Link and the route should hit /checkout. This route is not created yet, go to App.js and create the checkout Route. Render Checkout Component in this route. We will create this component now.

# Checkout.jsx create functional component, import necessary component from material ui core. create the layout for checkout. The stepper component creates step by step form design functionality. The first step is initially set to zero, we will use js to dynamically specify steps. Inside of the stepper, we map through all the steps. Declare the two steps we will have in const steps. Now inside the stepper, map through the steps and return an instant array function. Import useState so we can actually traverse through the steps. call useState as activeStep and setActiveStep with zero as default. Upon clicking Checkout, the steps shipping address, Payment details appears on a nice Paper.

# Implement different steps of the form as we. The first is Address Form, Payment Form, Review of the order. Still on the Checkout.jsx, Render two different components below the stepper, depending on which step are we currently on. Create Form as a functional component, return something based on which step are we currently on. Show AddressForm if we are on activeStep === 0, otherwise render PaymentForm. These components are not created yet. Just below </Stepper> if activeStep === 0 that is if we are on the last step, show Confirmation component else show Form component, which also has not yet been created yet. AddressForm and PaymentForm are for the first step shipping address, they are just changing.

# Create and import all these steps related component, AddressForm, PaymentForm, Create them in CheckoutForm folder. Create Functional component on AddressForm and PaymentForm. Import AddressForm and PaymentForm into Checkout.jsx. Create Confirmation as a functional component inside Checkout.jsx. Now we have the AddressForm, PaymentForm which belongs to the Form, and we also have Confirmation component skeletally ready. We should see AddressForm now in the UI. We cannot navigate yet though cos we do not have the button to set setActiveStep. At useState(0) AddressForm shows, at useState(1) PaymentForm shows. Implement Forms one by one

# AddressForm. Go to AddressForm.jsx file. Considering that AddressForm is going to have a lot of input, we will use React Hook Form to manage the input. Usually we will need to have specific state for each specific field, with React Hook Form, we can get the values out from input. First import required components from material ui core. Import react-hook-form. Setup react-hook-form. const methods = useForm(); gives access to all the methods that react-hook-form offers. Find a way to connect react-hook-form to material-ui just for design purpose. For this reason we create the component CustomTextField.jsx inside Checkout folder. In this component import TextField, Grid from material ui core and useFormContext, Controller from react-hook-form. setup CustomTextField function. Import CustomTextField into AddressForm.jsx

# Drop Down Menu in AddressForm.jsx. There are three categories Shipping Country, Shipping, Shipping Subdivision and Shipping option. The state of Shipping Country, determines the state of Shipping Subdivision, and the state of Shipping Subdivision determines the state of Shipping option. set all the useState. Now we use commerce API to fetch all Shipping countries, shipping divisions, shipping options for our customers. Recall, in commerce dashboard, we set that shipping can be made domestically in United State, and shipping can be made internationally to selected countries in Europe. import commerce from lib and declare a commerce instance, this instance allows us to use all of commerce features.

# Fetch Shipping Countries. Still in AddressForm.jsx, create the function fetchShippingCountries. This function takes in checkoutTokenId as parameter. You get this token once you select a country, like you coming to the store and you get a receipt. We anyways create the checkoutTokenId and pass it to countries. The checkoutTokenId is going to be created in the Checkout.jsx component where we have the steps and other part of the form. Go to Checkout.jsx, import useEffect. Initially we build this useEffect like a componentDidMount, but later on we change it when the cart changes. As soon as someone enters the checkout process, with the help of this useEffect, we generate the checkoutTokenId. Import commerce api here also. const token = await commerce.checkout.generateToken() This takes in two parameters, cartId and type of generated token. In here we need to have the cart. The problem is right now, the cart is in the App.js, and we don't have access to it in here. The simplest solution is to pass the cart as a prop in App.js, destructure this cart in Checkout.jsx file, create useState and useEffect functions to get the token. The token contains among other things analytics, collects, created, expires, gateway for payment, all items currently in cart, shipping methods.

# Now that we have this token, we have to pass it as a prop to AddressForm.jsx file. In AddressForm component rendered within Checkout.jsx, just pass in checkoutToken={checkoutToken}. Inside AddressForm.jsx, destructure checkoutToken, now we can use checkoutToken once we call fetchShippingCountries function. We call this function as soon as the AddressForm renders, we immediately want to get the countries. We use useEffect to accomplish this. the useEffect dependency array is left empty, componentDidMount. Now we have all the countries set in commerce js dashboard displayed in the console. The problem is when we reload, we get error cannot read property id of undefined. Pass in cart to dependency array of useEffect in Checkout.jsx file. This is so cos as soon as the cart changes we have to recall another token, also add the conditional render on Checkout.jsx file that render Form component only if we have checkoutToken. We now have the all countries in console and form working normally.

# Add select field for country and based on country we will fetch all the other regions. The countries currently are in object, we need them in array so we can loop over them. In AddressForm.jsx setShippingCountry(Object.keys(countries)[0]). In render uncomment out Shipping Country, just to test. set the value to shippingCountry and onChange to setShippingCountry targetting the value inside. We map over the countries, but first countries are not array, so we cannot perform countries.map. We can do {Object.entries} Object.entries give key value pair of this object i.e convert Object into a 2D array. Object.entries().map() this turns the 2D array into a normal array. Optimal this way const countries = Object.entries(shippingCountries).map(([code, name]) => ({id: code, label: name})); console.log(countries) gives one array with number of countries in them, each one has an id and label. Now we can use this, map over and show which one is selected. countries.map, for each country, return a block of jsx, which is the menu item. with key country.id, value will by country.id, text will be country.label. Now we have countries to be selected inside the select form.

# Populate subdivisions upon selecting a country. Still in AddressForm.jsx, create another function fetchSubdivision. This function accepts the parameter countryCode. We cannot call fetchSubdivisions function immediately after fetchShippingCountries, because at that time, we won't yet have the country. What we have to do is create another useEffect. This useEffect is going to have one dependency, that is going to be shippingCountry. So whenever shippingCountry changes, we call useEffect which houses fetchSubdivisions function. Convert subdivisions to array, loop over them and display based on selection. Only after we get the shipping country can we get the sub division for that specific country.

# Populate shipping options: for united states it is going to be free, for others it is going to be international paid. Same drill as populate subdivisions. We get the fetchShippingOptions after we have gotten fetchShippingCountries and fetchSubdivision. So we set another useEffect that runs only once the shippingSubdivision changes.

# We created in general 6 custom component input fields and three different selects.

# Add Btn to AddressForm.jsx.

ref number for application form 104344852

# still in AddressForm.jsx create six useState for shippingCountries up to shippingOptions. Use commerce api to fetch all available countries, shipping subdivision and shipping options for customers. Recall shipping countries, shipping subdivision and shipping options are the properties we set up in commerce js dashboard, that we can ship domestically in US and ship internationally to selected countries in Europe. import commerce.js file. Implement functionality to fetch those properties using commerce api.
